---
# This approach uses a `run_after:` shell script. This works everywhere,
# including RHEL/CentOS 7, but is hackish and non-obvious in `getcert list`.
# tests_certificate.yml covers a cleaner approach.
# yamllint disable rule:line-length
- name: Test certificate issuance with run_after shell script
  hosts: all
  vars:
    __test_cert_name: monger-cockpit
    __test_cert_files:
      - /etc/cockpit/ws-certs.d/{{ __test_cert_name }}.crt
      - "{{ __certificate_default_directory }}/certs/{{ __test_cert_name }}.crt"
    __test_key_files:
      - /etc/cockpit/ws-certs.d/{{ __test_cert_name }}.key
      - "{{ __certificate_default_directory }}/private/{{ __test_cert_name }}.key"
  tasks:
    - name: Set up for certificate tests
      include_tasks: tasks/setup_for_certificate_tests.yml

    # has to be done dynamically, as the first step checks it out
    - name: Generate certificate with certificate system role
      include_role:
        name: fedora.linux_system_roles.certificate
        public: true
      vars:
        certificate_requests:
          - name: "{{ __test_cert_name }}"
            dns: ['localhost', 'www.example.com']
            ca: local
            group: "{{ __cockpit_test_group
              if __cockpit_test_group else omit }}"
            # ideally we'd put the cert directly into /etc/cockpit/ws-certs.d;
            # however, cockpit in RHEL/CentOS 7 does not yet support a separate
            # key file, and lsr.certificate sets wrong permissions
            # (https://github.com/linux-system-roles/certificate/pull/97)
            run_after: |
              DEST=/etc/cockpit/ws-certs.d/{{ __test_cert_name }}.crt
              cat {{ __certificate_default_directory }}/certs/{{ __test_cert_name }}.crt \
              {{ __certificate_default_directory }}/private/{{ __test_cert_name }}.key > $DEST
              chmod 640 $DEST
              if [ -n "{{ __cockpit_test_group }}" ]; then
                chown root:{{ __cockpit_test_group }} $DEST
              fi

    - name: Validate installation
      block:
        # ostree cannot remove packages and cannot cleanup properly
        # this works around that issue
        - name: Restart cockpit to use the new certificates
          service:
            name: "{{ __cockpit_daemon }}"
            state: restarted
          when: __cockpit_is_ostree | d(false)

        # ugh, is there really no better way to do that?
        - name: Get PEM of certmonger's local CA
          command:
            cmd: >
              openssl pkcs12 -in /var/lib/certmonger/local/creds
              -out /var/lib/certmonger/local/ca.pem
              -nokeys -nodes -passin pass:""
            creates: /var/lib/certmonger/local/ca.pem

        - name: Test - cockpit works with TLS and expected certificate
          # noqa command-instead-of-module
          command:
            cmd: >
              curl --cacert /var/lib/certmonger/local/ca.pem
              https://localhost:9090
            # ansible 2.11's uri module has ca_path,
            # but that's still too new for us
          changed_when: false

        - name: Test - get certmonger tracking status
          command: >
            getcert list  --tracking-only -f
            {{ __certificate_default_directory }}/certs/{{ __test_cert_name }}.crt
          register: result
          changed_when: false

        - name: Test - ensure certificate generation succeeded
          assert:
            that: "'status: MONITORING' in result.stdout"

        - name: Test - clean up tracked certificate
          command: >
            getcert stop-tracking -f
            {{ __certificate_default_directory }}/certs/{{ __test_cert_name }}.crt
          changed_when: false

      always:
        - name: Test - generic cleanup
          include_tasks: tasks/cleanup.yml
